{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"tinyscibio","text":"<p>Convenient shortcut functions to boost daily bioinformatics tasks.</p>"},{"location":"#installation","title":"Installation","text":"<p>You can install tinyscibio from PyPI. Or simply add it to your package via package manager such as Rye.</p> piprye <pre><code>pip install tinyscibio\n</code></pre> <pre><code>rye add tinyscibio\nrye sync\n</code></pre> Note <p>tinyscibio works with CPython implementation of version 3.9, 3.10, 3.11, 3.12, 3.13.</p> <p>It has been tested and built on Linux and MacOS.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Coming soon..</p>"},{"location":"API/api_server/","title":"Request data from remote API server","text":""},{"location":"API/api_server/#tinyscibio.api_server.request_api_server","title":"<code>request_api_server(url, params=None, headers=None, timeout=None, stream=False)</code>","text":"<p>Connect to an API server given configuration and return a Response object.</p> <p>This is a wrapper around the get function from the requests package. I use this to query various remote biology databases with APIs, for instance, Varsome, Ensembl, GTEx, cBioPortal, etc.</p> <p>Examples:</p> <p>Let us query the Varsome API server to annotate a variant with ACMG information. Varsome requires API token to use the service. Provide an API token inside the HTTP header; otherwise, you can only run one API query once per day. The specific variant used here is from https://api.varsome.com/.</p> <pre><code>&gt;&gt;&gt; from tinyscibio import request_api_server\n&gt;&gt;&gt; api_server_url = \"https://api.varsome.com/lookup/\"\n&gt;&gt;&gt; qry = \"15-73027478-T-C\"\n&gt;&gt;&gt; lookup_path = f\"{api_server_url}{qry}\"\n&gt;&gt;&gt; qry_params = {\n        \"add_ACMG_annotation\": 1\n    }\n&gt;&gt;&gt; headers = {\"Accept\": \"application/json\"}\n&gt;&gt;&gt; response = request_api_server(\n        lookup_path,\n        qry_params,\n        headers\n    )\n&gt;&gt;&gt; assert response.status_code == 200  # if the connection is success\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>lookup path (not just the API server URL).</p> required <code>params</code> <code>Optional[_RequestParamsType]</code> <p>query parameters to defined what you want to request.</p> <code>None</code> <code>headers</code> <code>Optional[_RequestHeaderType]</code> <p>HTTP headers.</p> <code>None</code> <code>timeout</code> <code>Optional[float]</code> <p>How many seconds to wait for the server to send data      before giving up.</p> <code>None</code> <code>stream</code> <code>bool</code> <p>Whether or not getting response data immediately.</p> <code>False</code> <p>Returns:</p> Type Description <code>Response</code> <p>A requests.Response object.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>When HTTP error occurred.</p> <code>Timeout</code> <p>When request timed out.</p> <code>ConnectionError</code> <p>When connection error occurred.</p> <code>RequestException</code> <p>All other errors not covered by the above ones.</p>"},{"location":"API/bam/","title":"Work with BAM-related thingy","text":""},{"location":"API/bam/#tinyscibio.bam.BAMetadata","title":"<code>BAMetadata(fspath)</code>  <code>dataclass</code>","text":"<p>A BAMetadata object holds metadata about a given BAM file.</p> <p>Examples:</p> <p>Let us use a hypothetical coordinate-sorted BAM file with one read group and two references, as an example:</p> <pre><code>&gt;&gt;&gt; bametadata = BAMetadata(\"test.bam\")\n&gt;&gt;&gt; print(bametadata.sort_by)\ncoordinate\n&gt;&gt;&gt; print(bametadata.read_groups)\n[{\"ID\": \"test\", \"SM\": \"test\"}]\n&gt;&gt;&gt; print(bametadata.references)\n[{\"r1\": 1000}, {\"r2\": 2000}]\n&gt;&gt;&gt; print(bametadata)\nBAM file: test.bam\nSort by: coordinate\n# references: 2\n# read groups: 1\n</code></pre> <p>Attributes:</p> Name Type Description <code>fspath</code> <code>str</code> <p>path to the BAM file</p> <code>sort_by</code> <code>str</code> <p>sort state, e.g. unknown, unsorted, queryname, and coordinate.</p> <code>references</code> <code>list[dict[str, int]]</code> <p>list of mappings of reference name to its length.</p> <code>read_groups</code> <code>list[dict[str, str]]</code> <p>list of read group dictionaries</p>"},{"location":"API/bam/#tinyscibio.bam.count_indel_bases","title":"<code>count_indel_bases(cigar)</code>","text":"<p>Count the length of indels in the given CIGAR string.</p> <p>The function counts the number of bases, rather than events.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"45M9D27M1I20M5S\"\n&gt;&gt;&gt; assert count_indel_bases(cigar_str) == 10\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_indel_bases(cigar_list) == 1\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of inserted and deleted bases.</p>"},{"location":"API/bam/#tinyscibio.bam.count_indel_events","title":"<code>count_indel_events(cigar)</code>","text":"<p>Count the number of Is and Ds event in a given CIGAR string.</p> <p>Indel events include: insertion(I) and deletion(D).</p> <p>The function counts the number of events, rather than inserted and deleted bases.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"45H35M1D23M1I30S\"\n&gt;&gt;&gt; assert count_indel_events(cigar_str) == 2\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_indel_events(cigar_list) == 1\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of insertion and deletion events.</p>"},{"location":"API/bam/#tinyscibio.bam.count_mismatch_events","title":"<code>count_mismatch_events(md)</code>","text":"<p>Count the number of mismatch events in a given MD string.</p> <p>Mismatches are represented by any non-digit characters, e.g. A, C, G, ^T.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; md_str = \"10A3T0T10\"\n&gt;&gt;&gt; assert count_mismatch_events(md_str) == 3\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; md_list = [\"85\", \"^A\", \"16\"] # an inserted base A on the read\n&gt;&gt;&gt; assert count_mismatch_events(md_list) == 0\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>Union[str, Sequence[str]]</code> <p>a CIGAR string or a list strings parsed from parse_md() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of mismatch events.</p>"},{"location":"API/bam/#tinyscibio.bam.count_soft_clip_bases","title":"<code>count_soft_clip_bases(cigar)</code>","text":"<p>Count the number of soft-clipped bases from a given CIGAR string.</p> <p>Soft-clipped bases are represented as \"S\" in the CIGAR string.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"27S89M1I11M\"\n&gt;&gt;&gt; assert count_soft_clip_bases(cigar_str) == 27\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_soft_clip_bases(cigar_list) == 0\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_str = \"27S89M1I11M\"\n&gt;&gt;&gt; assert count_soft_clip_bases(parse_cigar(cigar_str)) == 27 # use result from parse_cigar function\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of soft-clipped bases.</p>"},{"location":"API/bam/#tinyscibio.bam.count_unaligned_events","title":"<code>count_unaligned_events(cigar)</code>","text":"<p>Count the number of unaligned events in a given CIGAR string.</p> <p>Unaligned events in this context include: insertion(I), deletion(D), soft-clipping(S), and hard-clipping(H).</p> <p>The function counts the number of events, rather than unaligned bases.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"45H35M1D23M1I30S\"\n&gt;&gt;&gt; assert count_unaligned_events(cigar_str) == 4\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_list = [(\"89\", \"M\"), (\"1\", \"I\"), (\"11\", \"M\")]\n&gt;&gt;&gt; assert count_unaligned_events(cigar_list) == 1\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; cigar_str = \"45H35M1D23M1I30S\"\n&gt;&gt;&gt; assert count_unaligned_events(parse_cigar(cigar_str)) == 4\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>Union[str, Sequence[tuple[str, str]]]</code> <p>a CIGAR string or a list of tuple items parsed by parse_cigar() function.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The number of unaligned events.</p>"},{"location":"API/bam/#tinyscibio.bam.parse_cigar","title":"<code>parse_cigar(cigar)</code>","text":"<p>Parse a given CIGAR string into a list of tuple items of (length, operation).</p> <p>Valid operations in a CIGAR string are: M, I, D, N, S, H, P, =, and X.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cigar_str = \"27S89M1I11M\"\n&gt;&gt;&gt; assert parse_cigar(cigar_str) == [\n    (\"27\", \"S\"),\n    (\"89\", \"M\"),\n    (\"1\", \"I\"),\n    (\"11\", \"M\")\n]\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>cigar</code> <code>str</code> <p>a CIGAR string</p> required <p>Returns:</p> Type Description <code>list[tuple[str, str]]</code> <p>A list of tuple items, each of which consists of length and operation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the given CIGAR string is empty, or when the CIGAR string         parsed into an empty list, or when failure of reconstructing         parsed list back to the original CIGAR string.</p>"},{"location":"API/bam/#tinyscibio.bam.parse_md","title":"<code>parse_md(md)</code>","text":"<p>Parse a given MD string into a list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; md_str = \"10A3T0T10\"\n&gt;&gt;&gt; assert parse_cigar(cigar_str) == [\n        \"10\", \"A\", \"3\", \"T\", \"0\", \"T\", \"10\"\n    ]\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>md</code> <code>str</code> <p>a MD string</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of strings.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>when the given MD string is empty, or when the MD string         parsed into an empty list, or when failure of reconstructing         parsed list back to the original MD string.</p>"},{"location":"API/bam/#tinyscibio.bam.parse_region","title":"<code>parse_region(region_string, one_based=True)</code>","text":"<p>Parse a given samtools-style region string into a tuple of rname, start, and end.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import parse_region\n&gt;&gt;&gt; region_str = \"chr1\"\n&gt;&gt;&gt; assert parse_region(region_str) == (\"chr1\", None, None)\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; region_str = \"chr1:100\"\n&gt;&gt;&gt; assert parse_region(region_str) == (\"chr1\", 100, None)\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; region_str = \"chr1:100-1000\"\n&gt;&gt;&gt; assert parse_region(region_str) == (\"chr1\", 100, 1000)\ntrue\n</code></pre> <pre><code>&gt;&gt;&gt; region_str = \"chr1:100-1000\"\n&gt;&gt;&gt; assert parse_region(region_str, one_based=True) == (\"chr1\", 99, 1000)\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>region_string</code> <code>str</code> <p>user-provide string following samtools-style            region definition.</p> required <code>one_based</code> <code>bool</code> <p>whether or not coordinate in the given string is one-based.</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[str, int | None, int | None]</code> <p>A tuple of (rname, start, end).</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When parser finds no matching pattern, or when start         is larger than end coordinate in the given region string.</p>"},{"location":"API/bam/#tinyscibio.bam.walk_bam","title":"<code>walk_bam(fspath, region, exclude=3840, chunk_size=100000, read_groups=None, return_ecnt=False, return_bq=False, return_md=False, return_qname=False, return_qseq=False)</code>","text":"<p>Traverse BAM file across given region and collect read-level alignment summary into a dataframe.</p> <p>Input BAM file must be sorted and indexed to make the walk feasible. Value to region parameter follows the samtools format, and therefore positions are 1-based.</p> <p>By default, walk_bam returns a dataframe with 7 columns:</p> <pre><code>- rnames: reference index (easy to map back to sequence name)\n- rstarts: 0-based start position on mapped reference\n- rends: same as above but marking the end of an alignment\n- mqs: mapping qualities\n- propers: whether or not a given alignment is properly aligned\n- primarys: whether or not a given alignment is primary\n- sc_bps: # of soft-clipped base pairs\n</code></pre> <p>When return_ecnt is set,</p> <pre><code>- mm_ecnt: # of mismatch events per alignment\n- mm_ecnt: # of indel events per alignment\n</code></pre> <p>When return_qname is set,</p> <pre><code>- qnames: read name\n</code></pre> <p>When return_qseq is set,</p> <pre><code>- qseqs: read sequence\n</code></pre> <p>When return_bq is set,</p> <pre><code>- bqs: base qualities in np.ndarray per alignment\n</code></pre> <p>When return_md is set,</p> <pre><code>- mds: parsed MD in np.ndarray per alignment\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import BAMetadata, walk_bam\n&gt;&gt;&gt; bam_fspath = \"example.bam\"\n&gt;&gt;&gt; bametadata = BAMetadata(bam_fspath)\n</code></pre> <p>Traverse entire region of HLA_A_01_01_01_01 allele:</p> <pre><code>&gt;&gt;&gt; region_str = \"hla_a_01_01_01_01\"\n&gt;&gt;&gt; df = walk_bam(bam_fspath, region_str)\n&gt;&gt;&gt; df = df.with_columns(\n    pl.col(\"rnames\").replace_strict(bametadata.idx2seqnames())\n)\n&gt;&gt;&gt; df.head()\nshape: (5, 7)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 rnames            \u2506 rstarts \u2506 rends \u2506 mqs \u2506 propers \u2506 primarys \u2506 sc_bps \u2502\n\u2502 ---               \u2506 ---     \u2506 ---   \u2506 --- \u2506 ---     \u2506 ---      \u2506 ---    \u2502\n\u2502 str               \u2506 i32     \u2506 i32   \u2506 u8  \u2506 bool    \u2506 bool     \u2506 i16    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 hla_a_01_01_01_01 \u2506 4       \u2506 104   \u2506 0   \u2506 true    \u2506 false    \u2506 0      \u2502\n\u2502 hla_a_01_01_01_01 \u2506 4       \u2506 102   \u2506 0   \u2506 true    \u2506 false    \u2506 0      \u2502\n\u2502 hla_a_01_01_01_01 \u2506 128     \u2506 229   \u2506 0   \u2506 true    \u2506 false    \u2506 0      \u2502\n\u2502 hla_a_01_01_01_01 \u2506 287     \u2506 388   \u2506 0   \u2506 true    \u2506 false    \u2506 0      \u2502\n\u2502 hla_a_01_01_01_01 \u2506 294     \u2506 395   \u2506 0   \u2506 true    \u2506 false    \u2506 0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Traverse the same region and collect more alignment summaries:</p> <pre><code>&gt;&gt;&gt; df = walk_bam(bam_fspath, region_str, return_ecnt=True, return_qname=True)\n&gt;&gt;&gt; df = df.with_columns(\n    pl.col(\"rnames\").replace_strict(bametadata.idx2seqnames())\n)\n&gt;&gt;&gt; df.head()\nshape: (5, 10)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 rnames            \u2506 rstarts \u2506 rends \u2506 mqs \u2506 \u2026 \u2506 sc_bps \u2506 qnames             \u2506 mm_ecnt \u2506 indel_ecnt \u2502\n\u2502 ---               \u2506 ---     \u2506 ---   \u2506 --- \u2506   \u2506 ---    \u2506 ---                \u2506 ---     \u2506 ---        \u2502\n\u2502 str               \u2506 i32     \u2506 i32   \u2506 u8  \u2506   \u2506 i16    \u2506 str                \u2506 i16     \u2506 i16        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 hla_a_01_01_01_01 \u2506 4       \u2506 104   \u2506 0   \u2506 \u2026 \u2506 0      \u2506 SRR702076.16980922 \u2506 0       \u2506 1          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 4       \u2506 102   \u2506 0   \u2506 \u2026 \u2506 0      \u2506 SRR702076.16980922 \u2506 0       \u2506 1          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 128     \u2506 229   \u2506 0   \u2506 \u2026 \u2506 0      \u2506 SRR702076.10444434 \u2506 6       \u2506 0          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 287     \u2506 388   \u2506 0   \u2506 \u2026 \u2506 0      \u2506 SRR702076.10444434 \u2506 10      \u2506 0          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 294     \u2506 395   \u2506 0   \u2506 \u2026 \u2506 0      \u2506 SRR702076.2819225  \u2506 0       \u2506 0          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Traverse the HLA_A_01_01_01_01 allele starting at position 100. Note that walk_bam has different behavior from pysam.AlignmentFile.fetch() function. It only grabs alignments from postion 100 and onwards.</p> <pre><code>&gt;&gt;&gt; region_str = \"hla_a_01_01_01_01:100\"\n&gt;&gt;&gt; df = walk_bam(bam_fspath, region_str, return_ecnt=True)\n&gt;&gt;&gt; df = df.with_columns(\n    pl.col(\"rnames\").replace_strict(bametadata.idx2seqnames())\n)\n&gt;&gt;&gt; df.head()\nshape: (5, 9)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 rnames            \u2506 rstarts \u2506 rends \u2506 mqs \u2506 \u2026 \u2506 primarys \u2506 sc_bps \u2506 mm_ecnt \u2506 indel_ecnt \u2502\n\u2502 ---               \u2506 ---     \u2506 ---   \u2506 --- \u2506   \u2506 ---      \u2506 ---    \u2506 ---     \u2506 ---        \u2502\n\u2502 str               \u2506 i32     \u2506 i32   \u2506 u8  \u2506   \u2506 bool     \u2506 i16    \u2506 i16     \u2506 i16        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 hla_a_01_01_01_01 \u2506 128     \u2506 229   \u2506 0   \u2506 \u2026 \u2506 false    \u2506 0      \u2506 6       \u2506 0          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 287     \u2506 388   \u2506 0   \u2506 \u2026 \u2506 false    \u2506 0      \u2506 10      \u2506 0          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 294     \u2506 395   \u2506 0   \u2506 \u2026 \u2506 false    \u2506 0      \u2506 0       \u2506 0          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 341     \u2506 442   \u2506 0   \u2506 \u2026 \u2506 false    \u2506 0      \u2506 0       \u2506 0          \u2502\n\u2502 hla_a_01_01_01_01 \u2506 638     \u2506 724   \u2506 0   \u2506 \u2026 \u2506 false    \u2506 0      \u2506 9       \u2506 1          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>fspath</code> <code>str</code> <p>Path pointing to the BAM file.</p> required <code>region</code> <code>str</code> <p>Region string in samtools style, e.g. chr1:100-1000.</p> required <code>exclude</code> <code>int</code> <p>Skip alignments whose flags are set with any bits defined.</p> <code>3840</code> <code>chunk_size</code> <code>int</code> <p>Maximum size of arrays to be held in memory at one time.</p> <code>100000</code> <code>read_groups</code> <code>Optional[Set[str]]</code> <p>Set of read groups whose alignments are retrieved.</p> <code>None</code> <code>return_ecnt</code> <code>bool</code> <p>Whether or not returning number of mismatch+indel events.</p> <code>False</code> <code>return_bq</code> <code>bool</code> <p>Whether or not returning base qualities.</p> <code>False</code> <code>return_md</code> <code>bool</code> <p>Whether or not returning parsed MD tuples.</p> <code>False</code> <code>return_qname</code> <code>bool</code> <p>Whether or not returning query/read names.</p> <code>False</code> <code>return_qseq</code> <code>bool</code> <p>Whether or not returning query/read sequences.</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Collection of summaries of read alignments in dataframe.</p>"},{"location":"API/intervals/","title":"Intervals","text":""},{"location":"API/intervals/#tinyscibio._intervals.NoMatchingChr","title":"<code>NoMatchingChr</code>","text":"<p>               Bases: <code>Exception</code></p> <p>When no matching chromosome found between query and subject</p>"},{"location":"API/intervals/#tinyscibio._intervals.NotInt64StartEnd","title":"<code>NotInt64StartEnd</code>","text":"<p>               Bases: <code>Exception</code></p> <p>When columns for start and end coords are not of type Int64</p>"},{"location":"API/intervals/#tinyscibio._intervals.NotSatisfyMinColReq","title":"<code>NotSatisfyMinColReq</code>","text":"<p>               Bases: <code>Exception</code></p> <p>When input does not meet the requirement of minimum 3 columns</p>"},{"location":"API/intervals/#tinyscibio._intervals.bed_to_df","title":"<code>bed_to_df(bed_file, one_based=False)</code>","text":"<p>Retrieve intervals from given BED file.</p> <p>Examples:</p> <p>Assuming we have a BED file with the following intervals:</p> <p>\u2502 chr6 \u2506 29909037 \u2506 29913661 \u2502</p> <p>\u2502 chr6 \u2506 31236526 \u2506 31239869 \u2502</p> <p>\u2502 chr6 \u2506 31321649 \u2506 31324964 \u2502</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from tinyscbio import bed_to_df\n&gt;&gt;&gt; bed_file = \"hla.bed\"\n&gt;&gt;&gt; bed_to_df(bed_file)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 column_1 \u2506 column_2 \u2506 column_3 \u2502\n\u2502 ---      \u2506 ---      \u2506 ---      \u2502\n\u2502 str      \u2506 i64      \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 chr6     \u2506 29909037 \u2506 29913661 \u2502\n\u2502 chr6     \u2506 31236526 \u2506 31239869 \u2502\n\u2502 chr6     \u2506 31321649 \u2506 31324964 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>bed_file</code> <code>_PathLike</code> <p>string or path object pointing to a BED file.</p> required <code>one_based</code> <code>bool</code> <p>whether or not the given BED file is 1-based</p> <code>False</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>polars dataframe with input columns.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>when the given path to the BED file does not exist.</p> <code>NotSatisfyMinColReq</code> <p>when input qry and/or subj dataframes fail to                  have a minimum of 3 columns.</p> <code>NotInt64StartEnd</code> <p>when 2<sup>nd</sup> and 3<sup>rd</sup> columns of qry and/or subj               dataframes have non-int64 types.</p>"},{"location":"API/intervals/#tinyscibio._intervals.find_overlaps","title":"<code>find_overlaps(qry, subj)</code>","text":"<p>Find overlaps between query and subject intervals. Strand is not taken into consideration at the moment.</p> <p>The function returns an empty (not None) polars dataframe if no overlapping intervals are found.</p> <p>Also, \"_q\" and \"_s\" are automatically appended to column names of the query and subject dataframes, respectively, to avoid column name conflict error when combining overlapping intervals from query and subject.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from tinyscibio import find_overlaps\n&gt;&gt;&gt; qry = pl.DataFrame(\n...    {\n...        \"column_1\": [\"chr1\", \"chr2\", \"chr3\"],\n...        \"column_2\": [1, 200, 800],\n...        \"column_3\": [51, 240, 850]\n...    }\n... )\n&gt;&gt;&gt; subj = pl.DataFrame(\n...    {\n...        \"column_1\": [\"chr1\", \"chr2\"],\n...        \"column_2\": [38, 120],\n...        \"column_3\": [95, 330]\n...    }\n... )\n&gt;&gt;&gt; find_overlaps(qry, subj)\nshape: (2, 6)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 column_1_q \u2506 column_2_q \u2506 column_3_q \u2506 column_1_s \u2506 column_2_s \u2506 column_3_s \u2502\n\u2502 ---        \u2506 ---        \u2506 ---        \u2506 ---        \u2506 ---        \u2506 ---        \u2502\n\u2502 str        \u2506 i64        \u2506 i64        \u2506 str        \u2506 i64        \u2506 i64        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 chr1       \u2506 1          \u2506 51         \u2506 chr1       \u2506 38         \u2506 95         \u2502\n\u2502 chr2       \u2506 200        \u2506 240        \u2506 chr2       \u2506 120        \u2506 330        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>qry</code> <code>DataFrame</code> <p>query intervals in dataframe.</p> required <code>subj</code> <code>DataFrame</code> <p>subject intervals from which qry querys.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>polars dataframe with overlapping intervals between</p> <code>DataFrame</code> <p>query and subject inputs.</p> <p>Raises:</p> Type Description <code>NotSatisfyMinColReq</code> <p>when input qry and/or subj dataframes fail to                  have a minimum of 3 columns.</p> <code>NotInt64StartEnd</code> <p>when 2<sup>nd</sup> and 3<sup>rd</sup> columns of qry and/or subj               dataframes have non-int64 types.</p> <code>NoMatchingChr</code> <p>when no matching chromosomes (1<sup>st</sup> column) found between            qry and subj dataframes.</p>"},{"location":"API/io/","title":"Work with file system","text":""},{"location":"API/io/#tinyscibio._io.parse_path","title":"<code>parse_path(path)</code>","text":"<p>Parse a string literal or a Path object into a Path object.</p> <p>In the latter case, the function does not do anything but return the given Path object directly.</p> <p>I also use this function to directly parse file and directory input strings passed in from command line.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import parse_path\n&gt;&gt;&gt; p = \"/home/user1/project\"\n&gt;&gt;&gt; parse_path(p)\nPath(\"/home/user1/project\")\n</code></pre> <pre><code>&gt;&gt;&gt; from pathlib import Path\n&gt;&gt;&gt; from tinyscibio import parse_path\n&gt;&gt;&gt; p_obj = Path(\"/home/user1/project\")\n&gt;&gt;&gt; parse_path(p_obj)\nPath(\"/home/user1/project\")\n</code></pre> <pre><code>&gt;&gt;&gt; from tinyscibio import parse_path\n&gt;&gt;&gt; import argparse\n&gt;&gt;&gt; parser = argparse.ArgumentParser()\n&gt;&gt;&gt; parser.add_argument(\n        \"--bam\",\n        metavar=\"FILE\",\n        type=parse_path,\n        help=\"Specify the path to the BAM file\"\n    )\n&gt;&gt;&gt; args = parser.parse_args()\n&gt;&gt;&gt; isinstance(args.bam, Path)\ntrue\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>_PathLike</code> <p>Either a string literal or a Path object.</p> required <p>Returns:</p> Type Description <code>Path</code> <p>A Path object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When input path parameter is an empty string</p>"},{"location":"API/io/#tinyscibio._io.make_dir","title":"<code>make_dir(path, parents=False, exist_ok=False)</code>","text":"<p>Create a directory at the specified location.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import make_dir\n&gt;&gt;&gt; p = \"/home/user1/projects\"\n&gt;&gt;&gt; new_p = make_dir(p, parents=True, exist_ok=True)\n&gt;&gt;&gt; new_p\nPath(\"/home/user1/projects\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>_PathLike</code> <p>Either a string literal or a Path object.</p> required <code>parents</code> <code>bool</code> <p>Whether or not creating parental folders leading      to the given path when not existed.</p> <code>False</code> <code>exist_ok</code> <code>bool</code> <p>Whether or not allowing the directory trying to be       created already existed.</p> <code>False</code> <p>Returns:</p> Type Description <code>Path</code> <p>A Path object pointing to the newly created directory.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>When parental folders leading to the given path                does not exists, and parents parameter is False</p> <code>FileExistsError</code> <p>When trying to create a directory that already              existed, and exist_ok parameter is False.              Or when trying to create a directory at the given              location leading to a file.</p>"},{"location":"API/io/#tinyscibio._io.get_parent_dir","title":"<code>get_parent_dir(path, level=0)</code>","text":"<p>Get parent directory at the specified level for a given path.</p> <p>Setting a level=0 means return the given path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tinyscibio import get_parent_dir\n&gt;&gt;&gt; p = \"/home/user1/projects\"\n&gt;&gt;&gt; get_parent_dir(p, level=1)\nPath(\"/home/user1/\")\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>_PathLike</code> <p>Either a string literal or a Path object.</p> required <code>level</code> <code>int</code> <p>Num of levels to walk back along a givne path</p> <code>0</code> <p>Returns:</p> Type Description <code>Path</code> <p>A Path object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When the value of level is negative or larger than         the number of parent folders in the given path</p>"}]}